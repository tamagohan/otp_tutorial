# Erlangの並行性について

Erlangの並行性は軽量プロセスと非同期メッセージに基づいている。
なぜ、Erlangが上記の手法をとったかはErlang自体が電話交換器の開発のために開発されたことに基づいている。

電話交換器においては大量のユーザのリクエストをさばくことができる点となによりコードを決して止めないくらいの信頼性が重要であった。
下記ではこの要件を個別に見ていく。

## スケーラビリティ

ユーザをある特定のイベント(呼び出しを受ける)に反応するだけのプロセスとして表すと理想的なシステムは小さな計算をしてイベントが来るたびにすばやく切り替わるプロセスをサポートすることになる。
つまり、プロセスプールを持たずに必要なだけプロセスを使えるようにするためには軽量なプロセスであることが求められる。

## フォールトトレランス

信頼性の高いシステムを作るには障害に対して頑強である必要がある。
そのためにはあらゆる障害を想定したチェックをすることが必要になるが、全てのバグを防ぐことは難しく、仮にバグが起きなかったとしてもハードウェア障害などは防ぐことが難しい。

そのため、全てを防ごうとするのではなく、それが起きたときにうまく対処する方法を探そうという方針が取られた。
電話交換器などで発生する障害はネットワーク障害が多いが、その多くが一時的な障害であり、リトライなどで対処できることが多いというのが背景にある。
そのため、データを破損するようなエラーはシステムの障害がある部分を早めに殺し、他に伝播させないことが重要になる。
また、その際に「きれいに殺す」ことが重要である。つまり、プロセス間でデータを共有していたり、ロックしていたりする場合、プロセスが死んだときにロックされたままになるなどデータの一貫性を保てない状態になることがある。

そのため、「データを共有しない」という方法が選ばれた。つまり、プロセス間でメッセージをやり取りするときはデータは全てコピーされる。これは速度の低下をもたらすがより安全である。

## 結論

上記の理由からErlangでは並行性を軽量プロセスとそれらのプロセス間でメッセージをやり取りすることで実現することとした。
具体的にはErlang VMはOSのプロセスを一つ用いてコア数の数だけスレッドを起動している。
このスレッドはスケジューラとして動作する。スケジューラは実行キューをもち、Erlangプロセスのリストをキューにいれている。
スケジューラは独自の基準でErlangプロセスを順次実行する。
(ここでErlangプロセスは処理が完了するまで次にErlangプロセスの処理に移れないわけではなく独自の計算方法で順次実行するErlangプロセスを切り替えている)

また、Erlangプロセス間はメッセージをやり取りして通信するが、そのメッセージは各プロセス間に一つだけ存在するmail boxにためられ、シーケンシャルに処理される。